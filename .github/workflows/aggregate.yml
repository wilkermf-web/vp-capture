name: Aggregate results.csv into public/aggregate.csv

on:
  push:
    paths:
      - "data/**"
  workflow_dispatch: {}
  schedule:
    - cron: "*/720 * * * *"

permissions:
  contents: write

jobs:
  build-aggregate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Node (no deps needed)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Aggregate data/**/results.csv -> public/aggregate.csv (somente data e valores)
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          function ensureDir(dir){ fs.mkdirSync(dir, { recursive:true }); }

          function listResultsFiles(root="data"){
            const out=[];
            function walk(d){
              if(!fs.existsSync(d)) return;
              for(const ent of fs.readdirSync(d, { withFileTypes:true })){
                const full = path.join(d, ent.name);
                if(ent.isDirectory()) walk(full);
                else if(ent.isFile() && ent.name === 'results.csv') out.push(full);
              }
            }
            walk(root);
            out.sort((a,b)=>a.localeCompare(b));
            return out;
          }

          // CSV com todos os campos entre aspas e ; como separador
          function parseCSVQuotedSemicolon(text){
            const lines = text.trim().split(/\r?\n/).filter(Boolean);
            if(!lines.length) return { header:[], rows:[] };
            const parseLine = (line) => {
              const fields=[];
              const re = /"((?:[^"]|"")*)"(?:;|$)/g;
              let m;
              while((m=re.exec(line))!==null){
                fields.push(m[1].replace(/""/g,'"'));
              }
              return fields;
            };
            const header = parseLine(lines.shift());
            const rows = lines
              .map(parseLine)
              .filter(arr=>arr.length===header.length)
              .map(arr=>Object.fromEntries(header.map((h,i)=>[String(h).trim().toLowerCase(), arr[i]])));
            return { header, rows };
          }

          // >>> FIX: não remover ponto decimal quando já vier em "1282.25"
          function normalizePrice(v){
            if(v==null || v==='') return null;
            let s = String(v).trim();

            // tira R$, espaços e qualquer coisa não numérica (mantendo . , -)
            s = s.replace(/[^\d.,-]/g, '');

            // caso BR: termina com ",dd" (ex.: 1.282,25)
            if (/,\\d{2}$/.test(s) || (s.includes(',') && !s.includes('.'))) {
              // remove apenas pontos de milhar e troca vírgula por ponto
              s = s.replace(/\.(?=\d{3}(?:\D|$))/g,'');
              s = s.replace(',', '.');
            } else {
              // assume ponto como decimal (ex.: 1282.25 ou 1,234.56)
              // remove vírgulas de milhar (1,234.56 -> 1234.56)
              s = s.replace(/,(?=\d{3}(?:\D|$))/g, '');
              // mantém o ponto decimal
            }

            const n = Number.parseFloat(s);
            return Number.isFinite(n) ? Number(n.toFixed(2)) : null;
          }

          const files = listResultsFiles('data');
          const byDate = new Map(); // date -> [prices]

          for(const fp of files){
            try{
              const txt = fs.readFileSync(fp,'utf8');
              const { rows } = parseCSVQuotedSemicolon(txt);
              for(const r of rows){
                const date = r.date || '';
                const price = normalizePrice(r.price_brl);
                if(!date || price==null) continue;
                if(!byDate.has(date)) byDate.set(date, []);
                byDate.get(date).push(price);
              }
            }catch(e){
              console.error('Falhou em', fp, e.message);
            }
          }

          const dates = Array.from(byDate.keys()).sort();
          for(const d of dates){
            const uniqueSorted = Array.from(new Set(byDate.get(d))).sort((a,b)=>a-b);
            byDate.set(d, uniqueSorted);
          }

          ensureDir('public');
          const out = [];
          out.push('"date";"price_brl"');
          for(let idx=0; idx<dates.length; idx++){
            const d = dates[idx];
            for(const p of byDate.get(d)){
              out.push(`"${d}";"${p.toFixed(2)}"`);
            }
            if(idx < dates.length-1) out.push('');
          }
          fs.writeFileSync(path.join('public','aggregate.csv'), out.join('\n')+'\n', 'utf8');
          console.log(`[aggregate] dias: ${dates.length}, linhas: ${out.length}`);
          NODE

      - name: Commit & push public/aggregate.csv (if changed)
        shell: bash
        run: |
          git config user.name  "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git add public/aggregate.csv
          if git diff --cached --quiet; then
            echo "Sem mudanças para commitar."
          else
            git commit -m "build(aggregate): corrigir parsing de price_brl (respeita ponto decimal)"
            git push
          fi
